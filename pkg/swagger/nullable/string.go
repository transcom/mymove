package nullable

// inspired by
// https://github.com/romanyx/nullable/blob/master/string.go
//
// The Validate and ContextValidate methods below are needed by the
// code generated by go-swagger and so we create our own class

import (
	"bytes"
	"context"
	"encoding/json"

	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/validate"
)

// recognize the JSON null
var null = []byte("null")

// String represents a string that may be null or not
// present in json at all.
type String struct {
	Present bool // Present is true if key is present in json
	Value   *string
}

// NewString creates a new nullable String
func NewString(str string) String {
	return String{
		Present: true,
		Value:   &str,
	}
}

// NewNullString creates a null string
func NewNullString() String {
	return String{
		Present: true,
		Value:   nil,
	}
}

// UnmarshalJSON implements json.Marshaler interface.
func (s *String) UnmarshalJSON(data []byte) error {
	s.Present = true

	if bytes.Equal(data, null) {
		return nil
	}

	if err := json.Unmarshal(data, &s.Value); err != nil {
		return err
	}

	return nil
}

// String always validates ok
// this is called from the go swagger generated code
func (s *String) Validate(formats strfmt.Registry) error {
	if s.Present && s.Value != nil {
		/*  this only works for types listed in go/pkg/mod/github.com/go-openapi/strfmt@v0.21.1/format.go
		    and 'string' isn't one of those.
		    Note sure if using the `Add` function would work here, you'd be passing in a the type
		    `string` and a validator to use.

		    The below call got the following errors:
		                	            	validation failure list:
		                	            	ntsSacstring is an invalid type name
		                	            	ntsTacstring is an invalid type name
		                	            	sacstring is an invalid type name
		                	Test:       	TestHandlerSuite/TestUpdateOrderHandlerWithAmendedUploads

		if err := validate.FormatOf("value", "body", "string", *s.Value, formats); err != nil {
			return err
		}
		 */

		// This seems like it would give us what we want, but you'd have to create new
		// NullableString types like NullableStringTAC and NullableStringSAC and then
		// you could use the validate functions with hardcoded values. I don't think we can store
		// the validation constants in a shared lib (to make it generic) because we don't know which fieldname
		// is being used here

		// Tested this call out with maxLength: 2 and got he following errors:
		// Error:      	Received unexpected error:
		//	            validation failure list:
		//	            ntsSac.value in body should be at most 2 chars long
		//	            ntsTac.value in body should be at most 2 chars long
		//	            sac.value in body should be at most 2 chars long

		if err := validate.MaxLength("value", "body", *s.Value, 10); err != nil {
			return err
		}
	}

	return nil
}

// ContextValidate always validates ok
// this is called from the go swagger generated code
func (s *String) ContextValidate(context context.Context, formats strfmt.Registry) error {
	// always validate ok
	return nil
}

