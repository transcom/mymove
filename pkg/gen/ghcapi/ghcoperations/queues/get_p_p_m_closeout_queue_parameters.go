// Code generated by go-swagger; DO NOT EDIT.

package queues

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"net/http"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/runtime/middleware"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// NewGetPPMCloseoutQueueParams creates a new GetPPMCloseoutQueueParams object
//
// There are no default values defined in the spec.
func NewGetPPMCloseoutQueueParams() GetPPMCloseoutQueueParams {

	return GetPPMCloseoutQueueParams{}
}

// GetPPMCloseoutQueueParams contains all the bound params for the get p p m closeout queue operation
// typically these are obtained from a http.Request
//
// swagger:parameters getPPMCloseoutQueue
type GetPPMCloseoutQueueParams struct {

	// HTTP Request Object
	HTTPRequest *http.Request `json:"-"`

	/*user's actively logged in transportation office ID
	  In: query
	*/
	ActiveOfficeID *strfmt.UUID
	/*user's actively logged in role
	  In: query
	*/
	ActiveRole *string
	/*Used to illustrate which user is assigned to this payment request.

	  In: query
	*/
	AssignedTo *string
	/*filters by the branch of the move's service member
	  In: query
	*/
	Branch *string
	/*Latest date that closeout was initiated on a PPM on the move
	  In: query
	*/
	CloseoutInitiated *strfmt.DateTime
	/*closeout location
	  In: query
	*/
	CloseoutLocation *string
	/*filters using a counselingOffice name of the move
	  In: query
	*/
	CounselingOffice *string
	/*filters using a prefix match on the service member's last name
	  In: query
	*/
	CustomerName *string
	/*filters the name of the destination duty location on the orders
	  In: query
	*/
	DestinationDutyLocation *string
	/*filters to match the unique service member's DoD ID
	  In: query
	*/
	Edipi *string
	/*filters to match the unique service member's EMPLID
	  In: query
	*/
	Emplid *string
	/*filters to match the unique move code locator
	  In: query
	*/
	Locator *string
	/*As of right now the only ppm_shipments status is "NEEDS_CLOSEOUT". But we allow the frontend to "filter" this, it may be useful in the future. For now it'll always just be in need of closeout. If null we still show PPM moves needing closeout. Don't confuse this with the move's status. Move status and ppm shipment status are different.

	  In: query
	*/
	NeedsPPMCloseout *bool
	/*direction of sort order if applied
	  In: query
	*/
	Order *string
	/*order type
	  In: query
	*/
	OrderType *string
	/*filters the name of the origin duty location on the orders
	  Unique: true
	  In: query
	  Collection Format: multi
	*/
	OriginDutyLocation []string
	/*filters the GBLOC of the service member's origin duty location
	  In: query
	*/
	OriginGBLOC *string
	/*requested page number of paginated move results
	  In: query
	*/
	Page *int64
	/*maximum number of moves to show on each page of paginated results
	  In: query
	*/
	PerPage *int64
	/*filters the status of the PPM shipment
	  In: query
	*/
	PpmStatus *string
	/*filters PPM type
	  In: query
	*/
	PpmType *string
	/*filters the requested pickup date of a shipment on the move
	  In: query
	*/
	RequestedMoveDate *string
	/*field that results should be sorted by
	  In: query
	*/
	Sort *string
	/*filters the status of the move
	  Unique: true
	  In: query
	*/
	Status []string
	/*Start of the submitted at date in the user's local time zone converted to UTC
	  In: query
	*/
	SubmittedAt *strfmt.DateTime
	/*Used to return a queue for a GBLOC other than the default of the current user. Requires the HQ role or a secondary transportation office assignment. The parameter is ignored if the requesting user does not have the necessary role or assignment.

	  In: query
	*/
	ViewAsGBLOC *string
}

// BindRequest both binds and validates a request, it assumes that complex things implement a Validatable(strfmt.Registry) error interface
// for simple values it will use straight method calls.
//
// To ensure default values, the struct must have been initialized with NewGetPPMCloseoutQueueParams() beforehand.
func (o *GetPPMCloseoutQueueParams) BindRequest(r *http.Request, route *middleware.MatchedRoute) error {
	var res []error

	o.HTTPRequest = r

	qs := runtime.Values(r.URL.Query())

	qActiveOfficeID, qhkActiveOfficeID, _ := qs.GetOK("activeOfficeID")
	if err := o.bindActiveOfficeID(qActiveOfficeID, qhkActiveOfficeID, route.Formats); err != nil {
		res = append(res, err)
	}

	qActiveRole, qhkActiveRole, _ := qs.GetOK("activeRole")
	if err := o.bindActiveRole(qActiveRole, qhkActiveRole, route.Formats); err != nil {
		res = append(res, err)
	}

	qAssignedTo, qhkAssignedTo, _ := qs.GetOK("assignedTo")
	if err := o.bindAssignedTo(qAssignedTo, qhkAssignedTo, route.Formats); err != nil {
		res = append(res, err)
	}

	qBranch, qhkBranch, _ := qs.GetOK("branch")
	if err := o.bindBranch(qBranch, qhkBranch, route.Formats); err != nil {
		res = append(res, err)
	}

	qCloseoutInitiated, qhkCloseoutInitiated, _ := qs.GetOK("closeoutInitiated")
	if err := o.bindCloseoutInitiated(qCloseoutInitiated, qhkCloseoutInitiated, route.Formats); err != nil {
		res = append(res, err)
	}

	qCloseoutLocation, qhkCloseoutLocation, _ := qs.GetOK("closeoutLocation")
	if err := o.bindCloseoutLocation(qCloseoutLocation, qhkCloseoutLocation, route.Formats); err != nil {
		res = append(res, err)
	}

	qCounselingOffice, qhkCounselingOffice, _ := qs.GetOK("counselingOffice")
	if err := o.bindCounselingOffice(qCounselingOffice, qhkCounselingOffice, route.Formats); err != nil {
		res = append(res, err)
	}

	qCustomerName, qhkCustomerName, _ := qs.GetOK("customerName")
	if err := o.bindCustomerName(qCustomerName, qhkCustomerName, route.Formats); err != nil {
		res = append(res, err)
	}

	qDestinationDutyLocation, qhkDestinationDutyLocation, _ := qs.GetOK("destinationDutyLocation")
	if err := o.bindDestinationDutyLocation(qDestinationDutyLocation, qhkDestinationDutyLocation, route.Formats); err != nil {
		res = append(res, err)
	}

	qEdipi, qhkEdipi, _ := qs.GetOK("edipi")
	if err := o.bindEdipi(qEdipi, qhkEdipi, route.Formats); err != nil {
		res = append(res, err)
	}

	qEmplid, qhkEmplid, _ := qs.GetOK("emplid")
	if err := o.bindEmplid(qEmplid, qhkEmplid, route.Formats); err != nil {
		res = append(res, err)
	}

	qLocator, qhkLocator, _ := qs.GetOK("locator")
	if err := o.bindLocator(qLocator, qhkLocator, route.Formats); err != nil {
		res = append(res, err)
	}

	qNeedsPPMCloseout, qhkNeedsPPMCloseout, _ := qs.GetOK("needsPPMCloseout")
	if err := o.bindNeedsPPMCloseout(qNeedsPPMCloseout, qhkNeedsPPMCloseout, route.Formats); err != nil {
		res = append(res, err)
	}

	qOrder, qhkOrder, _ := qs.GetOK("order")
	if err := o.bindOrder(qOrder, qhkOrder, route.Formats); err != nil {
		res = append(res, err)
	}

	qOrderType, qhkOrderType, _ := qs.GetOK("orderType")
	if err := o.bindOrderType(qOrderType, qhkOrderType, route.Formats); err != nil {
		res = append(res, err)
	}

	qOriginDutyLocation, qhkOriginDutyLocation, _ := qs.GetOK("originDutyLocation")
	if err := o.bindOriginDutyLocation(qOriginDutyLocation, qhkOriginDutyLocation, route.Formats); err != nil {
		res = append(res, err)
	}

	qOriginGBLOC, qhkOriginGBLOC, _ := qs.GetOK("originGBLOC")
	if err := o.bindOriginGBLOC(qOriginGBLOC, qhkOriginGBLOC, route.Formats); err != nil {
		res = append(res, err)
	}

	qPage, qhkPage, _ := qs.GetOK("page")
	if err := o.bindPage(qPage, qhkPage, route.Formats); err != nil {
		res = append(res, err)
	}

	qPerPage, qhkPerPage, _ := qs.GetOK("perPage")
	if err := o.bindPerPage(qPerPage, qhkPerPage, route.Formats); err != nil {
		res = append(res, err)
	}

	qPpmStatus, qhkPpmStatus, _ := qs.GetOK("ppmStatus")
	if err := o.bindPpmStatus(qPpmStatus, qhkPpmStatus, route.Formats); err != nil {
		res = append(res, err)
	}

	qPpmType, qhkPpmType, _ := qs.GetOK("ppmType")
	if err := o.bindPpmType(qPpmType, qhkPpmType, route.Formats); err != nil {
		res = append(res, err)
	}

	qRequestedMoveDate, qhkRequestedMoveDate, _ := qs.GetOK("requestedMoveDate")
	if err := o.bindRequestedMoveDate(qRequestedMoveDate, qhkRequestedMoveDate, route.Formats); err != nil {
		res = append(res, err)
	}

	qSort, qhkSort, _ := qs.GetOK("sort")
	if err := o.bindSort(qSort, qhkSort, route.Formats); err != nil {
		res = append(res, err)
	}

	qStatus, qhkStatus, _ := qs.GetOK("status")
	if err := o.bindStatus(qStatus, qhkStatus, route.Formats); err != nil {
		res = append(res, err)
	}

	qSubmittedAt, qhkSubmittedAt, _ := qs.GetOK("submittedAt")
	if err := o.bindSubmittedAt(qSubmittedAt, qhkSubmittedAt, route.Formats); err != nil {
		res = append(res, err)
	}

	qViewAsGBLOC, qhkViewAsGBLOC, _ := qs.GetOK("viewAsGBLOC")
	if err := o.bindViewAsGBLOC(qViewAsGBLOC, qhkViewAsGBLOC, route.Formats); err != nil {
		res = append(res, err)
	}
	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// bindActiveOfficeID binds and validates parameter ActiveOfficeID from query.
func (o *GetPPMCloseoutQueueParams) bindActiveOfficeID(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}

	// Format: uuid
	value, err := formats.Parse("uuid", raw)
	if err != nil {
		return errors.InvalidType("activeOfficeID", "query", "strfmt.UUID", raw)
	}
	o.ActiveOfficeID = (value.(*strfmt.UUID))

	if err := o.validateActiveOfficeID(formats); err != nil {
		return err
	}

	return nil
}

// validateActiveOfficeID carries on validations for parameter ActiveOfficeID
func (o *GetPPMCloseoutQueueParams) validateActiveOfficeID(formats strfmt.Registry) error {

	if err := validate.FormatOf("activeOfficeID", "query", "uuid", o.ActiveOfficeID.String(), formats); err != nil {
		return err
	}
	return nil
}

// bindActiveRole binds and validates parameter ActiveRole from query.
func (o *GetPPMCloseoutQueueParams) bindActiveRole(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}
	o.ActiveRole = &raw

	return nil
}

// bindAssignedTo binds and validates parameter AssignedTo from query.
func (o *GetPPMCloseoutQueueParams) bindAssignedTo(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}
	o.AssignedTo = &raw

	return nil
}

// bindBranch binds and validates parameter Branch from query.
func (o *GetPPMCloseoutQueueParams) bindBranch(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}
	o.Branch = &raw

	return nil
}

// bindCloseoutInitiated binds and validates parameter CloseoutInitiated from query.
func (o *GetPPMCloseoutQueueParams) bindCloseoutInitiated(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}

	// Format: date-time
	value, err := formats.Parse("date-time", raw)
	if err != nil {
		return errors.InvalidType("closeoutInitiated", "query", "strfmt.DateTime", raw)
	}
	o.CloseoutInitiated = (value.(*strfmt.DateTime))

	if err := o.validateCloseoutInitiated(formats); err != nil {
		return err
	}

	return nil
}

// validateCloseoutInitiated carries on validations for parameter CloseoutInitiated
func (o *GetPPMCloseoutQueueParams) validateCloseoutInitiated(formats strfmt.Registry) error {

	if err := validate.FormatOf("closeoutInitiated", "query", "date-time", o.CloseoutInitiated.String(), formats); err != nil {
		return err
	}
	return nil
}

// bindCloseoutLocation binds and validates parameter CloseoutLocation from query.
func (o *GetPPMCloseoutQueueParams) bindCloseoutLocation(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}
	o.CloseoutLocation = &raw

	return nil
}

// bindCounselingOffice binds and validates parameter CounselingOffice from query.
func (o *GetPPMCloseoutQueueParams) bindCounselingOffice(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}
	o.CounselingOffice = &raw

	return nil
}

// bindCustomerName binds and validates parameter CustomerName from query.
func (o *GetPPMCloseoutQueueParams) bindCustomerName(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}
	o.CustomerName = &raw

	return nil
}

// bindDestinationDutyLocation binds and validates parameter DestinationDutyLocation from query.
func (o *GetPPMCloseoutQueueParams) bindDestinationDutyLocation(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}
	o.DestinationDutyLocation = &raw

	return nil
}

// bindEdipi binds and validates parameter Edipi from query.
func (o *GetPPMCloseoutQueueParams) bindEdipi(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}
	o.Edipi = &raw

	return nil
}

// bindEmplid binds and validates parameter Emplid from query.
func (o *GetPPMCloseoutQueueParams) bindEmplid(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}
	o.Emplid = &raw

	return nil
}

// bindLocator binds and validates parameter Locator from query.
func (o *GetPPMCloseoutQueueParams) bindLocator(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}
	o.Locator = &raw

	return nil
}

// bindNeedsPPMCloseout binds and validates parameter NeedsPPMCloseout from query.
func (o *GetPPMCloseoutQueueParams) bindNeedsPPMCloseout(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertBool(raw)
	if err != nil {
		return errors.InvalidType("needsPPMCloseout", "query", "bool", raw)
	}
	o.NeedsPPMCloseout = &value

	return nil
}

// bindOrder binds and validates parameter Order from query.
func (o *GetPPMCloseoutQueueParams) bindOrder(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}
	o.Order = &raw

	if err := o.validateOrder(formats); err != nil {
		return err
	}

	return nil
}

// validateOrder carries on validations for parameter Order
func (o *GetPPMCloseoutQueueParams) validateOrder(formats strfmt.Registry) error {

	if err := validate.EnumCase("order", "query", *o.Order, []interface{}{"asc", "desc"}, true); err != nil {
		return err
	}

	return nil
}

// bindOrderType binds and validates parameter OrderType from query.
func (o *GetPPMCloseoutQueueParams) bindOrderType(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}
	o.OrderType = &raw

	return nil
}

// bindOriginDutyLocation binds and validates array parameter OriginDutyLocation from query.
//
// Arrays are parsed according to CollectionFormat: "multi" (defaults to "csv" when empty).
func (o *GetPPMCloseoutQueueParams) bindOriginDutyLocation(rawData []string, hasKey bool, formats strfmt.Registry) error {
	// CollectionFormat: multi
	originDutyLocationIC := rawData
	if len(originDutyLocationIC) == 0 {
		return nil
	}

	var originDutyLocationIR []string
	for _, originDutyLocationIV := range originDutyLocationIC {
		originDutyLocationI := originDutyLocationIV

		originDutyLocationIR = append(originDutyLocationIR, originDutyLocationI)
	}

	o.OriginDutyLocation = originDutyLocationIR
	if err := o.validateOriginDutyLocation(formats); err != nil {
		return err
	}

	return nil
}

// validateOriginDutyLocation carries on validations for parameter OriginDutyLocation
func (o *GetPPMCloseoutQueueParams) validateOriginDutyLocation(formats strfmt.Registry) error {

	// uniqueItems: true
	if err := validate.UniqueItems("originDutyLocation", "query", o.OriginDutyLocation); err != nil {
		return err
	}
	return nil
}

// bindOriginGBLOC binds and validates parameter OriginGBLOC from query.
func (o *GetPPMCloseoutQueueParams) bindOriginGBLOC(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}
	o.OriginGBLOC = &raw

	return nil
}

// bindPage binds and validates parameter Page from query.
func (o *GetPPMCloseoutQueueParams) bindPage(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertInt64(raw)
	if err != nil {
		return errors.InvalidType("page", "query", "int64", raw)
	}
	o.Page = &value

	return nil
}

// bindPerPage binds and validates parameter PerPage from query.
func (o *GetPPMCloseoutQueueParams) bindPerPage(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertInt64(raw)
	if err != nil {
		return errors.InvalidType("perPage", "query", "int64", raw)
	}
	o.PerPage = &value

	return nil
}

// bindPpmStatus binds and validates parameter PpmStatus from query.
func (o *GetPPMCloseoutQueueParams) bindPpmStatus(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}
	o.PpmStatus = &raw

	if err := o.validatePpmStatus(formats); err != nil {
		return err
	}

	return nil
}

// validatePpmStatus carries on validations for parameter PpmStatus
func (o *GetPPMCloseoutQueueParams) validatePpmStatus(formats strfmt.Registry) error {

	if err := validate.EnumCase("ppmStatus", "query", *o.PpmStatus, []interface{}{"WAITING_ON_CUSTOMER", "NEEDS_CLOSEOUT"}, true); err != nil {
		return err
	}

	return nil
}

// bindPpmType binds and validates parameter PpmType from query.
func (o *GetPPMCloseoutQueueParams) bindPpmType(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}
	o.PpmType = &raw

	if err := o.validatePpmType(formats); err != nil {
		return err
	}

	return nil
}

// validatePpmType carries on validations for parameter PpmType
func (o *GetPPMCloseoutQueueParams) validatePpmType(formats strfmt.Registry) error {

	if err := validate.EnumCase("ppmType", "query", *o.PpmType, []interface{}{"FULL", "PARTIAL"}, true); err != nil {
		return err
	}

	return nil
}

// bindRequestedMoveDate binds and validates parameter RequestedMoveDate from query.
func (o *GetPPMCloseoutQueueParams) bindRequestedMoveDate(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}
	o.RequestedMoveDate = &raw

	return nil
}

// bindSort binds and validates parameter Sort from query.
func (o *GetPPMCloseoutQueueParams) bindSort(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}
	o.Sort = &raw

	if err := o.validateSort(formats); err != nil {
		return err
	}

	return nil
}

// validateSort carries on validations for parameter Sort
func (o *GetPPMCloseoutQueueParams) validateSort(formats strfmt.Registry) error {

	if err := validate.EnumCase("sort", "query", *o.Sort, []interface{}{"customerName", "edipi", "emplid", "branch", "locator", "status", "requestedMoveDate", "submittedAt", "originGBLOC", "originDutyLocation", "destinationDutyLocation", "ppmType", "closeoutInitiated", "closeoutLocation", "ppmStatus", "counselingOffice", "assignedTo"}, true); err != nil {
		return err
	}

	return nil
}

// bindStatus binds and validates array parameter Status from query.
//
// Arrays are parsed according to CollectionFormat: "" (defaults to "csv" when empty).
func (o *GetPPMCloseoutQueueParams) bindStatus(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var qvStatus string
	if len(rawData) > 0 {
		qvStatus = rawData[len(rawData)-1]
	}

	// CollectionFormat:
	statusIC := swag.SplitByFormat(qvStatus, "")
	if len(statusIC) == 0 {
		return nil
	}

	var statusIR []string
	for i, statusIV := range statusIC {
		statusI := statusIV

		if err := validate.EnumCase(fmt.Sprintf("%s.%v", "status", i), "query", statusI, []interface{}{"NEEDS SERVICE COUNSELING", "SERVICE COUNSELING COMPLETED"}, true); err != nil {
			return err
		}

		statusIR = append(statusIR, statusI)
	}

	o.Status = statusIR
	if err := o.validateStatus(formats); err != nil {
		return err
	}

	return nil
}

// validateStatus carries on validations for parameter Status
func (o *GetPPMCloseoutQueueParams) validateStatus(formats strfmt.Registry) error {

	// uniqueItems: true
	if err := validate.UniqueItems("status", "query", o.Status); err != nil {
		return err
	}
	return nil
}

// bindSubmittedAt binds and validates parameter SubmittedAt from query.
func (o *GetPPMCloseoutQueueParams) bindSubmittedAt(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}

	// Format: date-time
	value, err := formats.Parse("date-time", raw)
	if err != nil {
		return errors.InvalidType("submittedAt", "query", "strfmt.DateTime", raw)
	}
	o.SubmittedAt = (value.(*strfmt.DateTime))

	if err := o.validateSubmittedAt(formats); err != nil {
		return err
	}

	return nil
}

// validateSubmittedAt carries on validations for parameter SubmittedAt
func (o *GetPPMCloseoutQueueParams) validateSubmittedAt(formats strfmt.Registry) error {

	if err := validate.FormatOf("submittedAt", "query", "date-time", o.SubmittedAt.String(), formats); err != nil {
		return err
	}
	return nil
}

// bindViewAsGBLOC binds and validates parameter ViewAsGBLOC from query.
func (o *GetPPMCloseoutQueueParams) bindViewAsGBLOC(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}
	o.ViewAsGBLOC = &raw

	return nil
}
