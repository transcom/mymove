// Code generated by go-swagger; DO NOT EDIT.

package internalmessages

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// UpdatePersonallyProcuredMovePayload update personally procured move payload
//
// swagger:model UpdatePersonallyProcuredMovePayload
type UpdatePersonallyProcuredMovePayload struct {

	// When did you actually move?
	// Example: 2018-04-26
	// Format: date
	ActualMoveDate *strfmt.Date `json:"actual_move_date,omitempty"`

	// ZIP code
	// Example: 90210
	// Pattern: ^(\d{5}([\-]\d{4})?)$
	AdditionalPickupPostalCode *string `json:"additional_pickup_postal_code,omitempty"`

	// advance
	Advance *Reimbursement `json:"advance,omitempty"`

	// advance worksheet
	AdvanceWorksheet *DocumentPayload `json:"advance_worksheet,omitempty"`

	// How many days of storage do you think you'll need?
	// Maximum: 90
	// Minimum: 0
	DaysInStorage *int64 `json:"days_in_storage,omitempty"`

	// ZIP code
	// Example: 90210
	// Pattern: ^(\d{5}([\-]\d{4})?)$
	DestinationPostalCode *string `json:"destination_postal_code,omitempty"`

	// Estimated Storage Reimbursement
	EstimatedStorageReimbursement *string `json:"estimated_storage_reimbursement,omitempty"`

	// Will you move anything from another pickup location?
	HasAdditionalPostalCode *bool `json:"has_additional_postal_code,omitempty"`

	// Has Pro-Gear
	// Enum: [NOT SURE YES NO]
	HasProGear *string `json:"has_pro_gear,omitempty"`

	// Has Pro-Gear Over Thousand Pounds
	// Enum: [NOT SURE YES NO]
	HasProGearOverThousand *string `json:"has_pro_gear_over_thousand,omitempty"`

	// Would you like an advance of up to 60% of your PPM incentive?
	HasRequestedAdvance *bool `json:"has_requested_advance,omitempty"`

	// Will you put anything in storage?
	HasSit *bool `json:"has_sit,omitempty"`

	// Net Weight
	// Minimum: 1
	NetWeight *int64 `json:"net_weight,omitempty"`

	// When do you plan to move?
	// Example: 2018-04-26
	// Format: date
	OriginalMoveDate *strfmt.Date `json:"original_move_date,omitempty"`

	// ZIP code
	// Example: 90210
	// Pattern: ^(\d{5}([\-]\d{4})?)$
	PickupPostalCode *string `json:"pickup_postal_code,omitempty"`

	// size
	Size *TShirtSize `json:"size,omitempty"`

	// How much does your storage cost?
	// Minimum: 0
	TotalSitCost *int64 `json:"total_sit_cost,omitempty"`

	// Weight Estimate
	// Minimum: 0
	WeightEstimate *int64 `json:"weight_estimate,omitempty"`
}

// Validate validates this update personally procured move payload
func (m *UpdatePersonallyProcuredMovePayload) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateActualMoveDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAdditionalPickupPostalCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAdvance(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAdvanceWorksheet(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDaysInStorage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDestinationPostalCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHasProGear(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHasProGearOverThousand(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNetWeight(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOriginalMoveDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePickupPostalCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSize(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalSitCost(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWeightEstimate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *UpdatePersonallyProcuredMovePayload) validateActualMoveDate(formats strfmt.Registry) error {
	if swag.IsZero(m.ActualMoveDate) { // not required
		return nil
	}

	if err := validate.FormatOf("actual_move_date", "body", "date", m.ActualMoveDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *UpdatePersonallyProcuredMovePayload) validateAdditionalPickupPostalCode(formats strfmt.Registry) error {
	if swag.IsZero(m.AdditionalPickupPostalCode) { // not required
		return nil
	}

	if err := validate.Pattern("additional_pickup_postal_code", "body", *m.AdditionalPickupPostalCode, `^(\d{5}([\-]\d{4})?)$`); err != nil {
		return err
	}

	return nil
}

func (m *UpdatePersonallyProcuredMovePayload) validateAdvance(formats strfmt.Registry) error {
	if swag.IsZero(m.Advance) { // not required
		return nil
	}

	if m.Advance != nil {
		if err := m.Advance.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("advance")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("advance")
			}
			return err
		}
	}

	return nil
}

func (m *UpdatePersonallyProcuredMovePayload) validateAdvanceWorksheet(formats strfmt.Registry) error {
	if swag.IsZero(m.AdvanceWorksheet) { // not required
		return nil
	}

	if m.AdvanceWorksheet != nil {
		if err := m.AdvanceWorksheet.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("advance_worksheet")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("advance_worksheet")
			}
			return err
		}
	}

	return nil
}

func (m *UpdatePersonallyProcuredMovePayload) validateDaysInStorage(formats strfmt.Registry) error {
	if swag.IsZero(m.DaysInStorage) { // not required
		return nil
	}

	if err := validate.MinimumInt("days_in_storage", "body", *m.DaysInStorage, 0, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("days_in_storage", "body", *m.DaysInStorage, 90, false); err != nil {
		return err
	}

	return nil
}

func (m *UpdatePersonallyProcuredMovePayload) validateDestinationPostalCode(formats strfmt.Registry) error {
	if swag.IsZero(m.DestinationPostalCode) { // not required
		return nil
	}

	if err := validate.Pattern("destination_postal_code", "body", *m.DestinationPostalCode, `^(\d{5}([\-]\d{4})?)$`); err != nil {
		return err
	}

	return nil
}

var updatePersonallyProcuredMovePayloadTypeHasProGearPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["NOT SURE","YES","NO"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		updatePersonallyProcuredMovePayloadTypeHasProGearPropEnum = append(updatePersonallyProcuredMovePayloadTypeHasProGearPropEnum, v)
	}
}

const (

	// UpdatePersonallyProcuredMovePayloadHasProGearNOTSURE captures enum value "NOT SURE"
	UpdatePersonallyProcuredMovePayloadHasProGearNOTSURE string = "NOT SURE"

	// UpdatePersonallyProcuredMovePayloadHasProGearYES captures enum value "YES"
	UpdatePersonallyProcuredMovePayloadHasProGearYES string = "YES"

	// UpdatePersonallyProcuredMovePayloadHasProGearNO captures enum value "NO"
	UpdatePersonallyProcuredMovePayloadHasProGearNO string = "NO"
)

// prop value enum
func (m *UpdatePersonallyProcuredMovePayload) validateHasProGearEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, updatePersonallyProcuredMovePayloadTypeHasProGearPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *UpdatePersonallyProcuredMovePayload) validateHasProGear(formats strfmt.Registry) error {
	if swag.IsZero(m.HasProGear) { // not required
		return nil
	}

	// value enum
	if err := m.validateHasProGearEnum("has_pro_gear", "body", *m.HasProGear); err != nil {
		return err
	}

	return nil
}

var updatePersonallyProcuredMovePayloadTypeHasProGearOverThousandPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["NOT SURE","YES","NO"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		updatePersonallyProcuredMovePayloadTypeHasProGearOverThousandPropEnum = append(updatePersonallyProcuredMovePayloadTypeHasProGearOverThousandPropEnum, v)
	}
}

const (

	// UpdatePersonallyProcuredMovePayloadHasProGearOverThousandNOTSURE captures enum value "NOT SURE"
	UpdatePersonallyProcuredMovePayloadHasProGearOverThousandNOTSURE string = "NOT SURE"

	// UpdatePersonallyProcuredMovePayloadHasProGearOverThousandYES captures enum value "YES"
	UpdatePersonallyProcuredMovePayloadHasProGearOverThousandYES string = "YES"

	// UpdatePersonallyProcuredMovePayloadHasProGearOverThousandNO captures enum value "NO"
	UpdatePersonallyProcuredMovePayloadHasProGearOverThousandNO string = "NO"
)

// prop value enum
func (m *UpdatePersonallyProcuredMovePayload) validateHasProGearOverThousandEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, updatePersonallyProcuredMovePayloadTypeHasProGearOverThousandPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *UpdatePersonallyProcuredMovePayload) validateHasProGearOverThousand(formats strfmt.Registry) error {
	if swag.IsZero(m.HasProGearOverThousand) { // not required
		return nil
	}

	// value enum
	if err := m.validateHasProGearOverThousandEnum("has_pro_gear_over_thousand", "body", *m.HasProGearOverThousand); err != nil {
		return err
	}

	return nil
}

func (m *UpdatePersonallyProcuredMovePayload) validateNetWeight(formats strfmt.Registry) error {
	if swag.IsZero(m.NetWeight) { // not required
		return nil
	}

	if err := validate.MinimumInt("net_weight", "body", *m.NetWeight, 1, false); err != nil {
		return err
	}

	return nil
}

func (m *UpdatePersonallyProcuredMovePayload) validateOriginalMoveDate(formats strfmt.Registry) error {
	if swag.IsZero(m.OriginalMoveDate) { // not required
		return nil
	}

	if err := validate.FormatOf("original_move_date", "body", "date", m.OriginalMoveDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *UpdatePersonallyProcuredMovePayload) validatePickupPostalCode(formats strfmt.Registry) error {
	if swag.IsZero(m.PickupPostalCode) { // not required
		return nil
	}

	if err := validate.Pattern("pickup_postal_code", "body", *m.PickupPostalCode, `^(\d{5}([\-]\d{4})?)$`); err != nil {
		return err
	}

	return nil
}

func (m *UpdatePersonallyProcuredMovePayload) validateSize(formats strfmt.Registry) error {
	if swag.IsZero(m.Size) { // not required
		return nil
	}

	if m.Size != nil {
		if err := m.Size.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("size")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("size")
			}
			return err
		}
	}

	return nil
}

func (m *UpdatePersonallyProcuredMovePayload) validateTotalSitCost(formats strfmt.Registry) error {
	if swag.IsZero(m.TotalSitCost) { // not required
		return nil
	}

	if err := validate.MinimumInt("total_sit_cost", "body", *m.TotalSitCost, 0, false); err != nil {
		return err
	}

	return nil
}

func (m *UpdatePersonallyProcuredMovePayload) validateWeightEstimate(formats strfmt.Registry) error {
	if swag.IsZero(m.WeightEstimate) { // not required
		return nil
	}

	if err := validate.MinimumInt("weight_estimate", "body", *m.WeightEstimate, 0, false); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this update personally procured move payload based on the context it is used
func (m *UpdatePersonallyProcuredMovePayload) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAdvance(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAdvanceWorksheet(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSize(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *UpdatePersonallyProcuredMovePayload) contextValidateAdvance(ctx context.Context, formats strfmt.Registry) error {

	if m.Advance != nil {
		if err := m.Advance.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("advance")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("advance")
			}
			return err
		}
	}

	return nil
}

func (m *UpdatePersonallyProcuredMovePayload) contextValidateAdvanceWorksheet(ctx context.Context, formats strfmt.Registry) error {

	if m.AdvanceWorksheet != nil {
		if err := m.AdvanceWorksheet.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("advance_worksheet")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("advance_worksheet")
			}
			return err
		}
	}

	return nil
}

func (m *UpdatePersonallyProcuredMovePayload) contextValidateSize(ctx context.Context, formats strfmt.Registry) error {

	if m.Size != nil {
		if err := m.Size.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("size")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("size")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *UpdatePersonallyProcuredMovePayload) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *UpdatePersonallyProcuredMovePayload) UnmarshalBinary(b []byte) error {
	var res UpdatePersonallyProcuredMovePayload
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
