package ppmcloseout

import (
	"database/sql"
	"fmt"

	"github.com/gofrs/uuid"
	"github.com/jinzhu/copier"
	"go.uber.org/zap"

	"github.com/transcom/mymove/pkg/appcontext"
	"github.com/transcom/mymove/pkg/apperror"
	"github.com/transcom/mymove/pkg/db/utilities"
	"github.com/transcom/mymove/pkg/models"
	paymentrequesthelper "github.com/transcom/mymove/pkg/payment_request"
	serviceparamvaluelookups "github.com/transcom/mymove/pkg/payment_request/service_param_value_lookups"
	"github.com/transcom/mymove/pkg/route"
	"github.com/transcom/mymove/pkg/services"
	"github.com/transcom/mymove/pkg/services/ghcrateengine"
	"github.com/transcom/mymove/pkg/services/ppmshipment"
	"github.com/transcom/mymove/pkg/unit"
)

type ppmCloseoutFetcher struct {
	planner              route.Planner
	paymentRequestHelper paymentrequesthelper.Helper
	estimator            services.PPMEstimator
}

type serviceItemPrices struct {
	ddp                       *unit.Cents
	dop                       *unit.Cents
	packPrice                 *unit.Cents
	unpackPrice               *unit.Cents
	storageReimbursementCosts *unit.Cents
	haulPrice                 *unit.Cents
	haulFSC                   *unit.Cents
	haulType                  models.HaulType
	intlPackPrice             *unit.Cents
	intlUnpackPrice           *unit.Cents
	intlLinehaulPrice         *unit.Cents
}

func NewPPMCloseoutFetcher(planner route.Planner, paymentRequestHelper paymentrequesthelper.Helper, estimator services.PPMEstimator) services.PPMCloseoutFetcher {
	return &ppmCloseoutFetcher{
		planner,
		paymentRequestHelper,
		estimator,
	}
}

func (p *ppmCloseoutFetcher) GetPPMCloseout(appCtx appcontext.AppContext, ppmShipmentID uuid.UUID) (*models.PPMCloseout, error) {
	var ppmCloseoutObj models.PPMCloseout
	ppmShipment, err := p.GetPPMShipment(appCtx, ppmShipmentID)
	if err != nil {
		return nil, err
	}
	previousFinalIncentive := ppmShipment.FinalIncentive

	actualWeight := p.GetActualWeight(ppmShipment)

	proGearWeightCustomer, proGearWeightSpouse := p.GetProGearWeights(*ppmShipment)

	var remainingIncentive unit.Cents
	// Most moves generated by `make db_dev_e2e_populate` skip the part that generates the FinalIncentive for the move, so just return 0.
	// Moves created through the UI shouldn't be able to skip this part
	ppmShipment.FinalIncentive, err = p.estimator.FinalIncentiveWithDefaultChecks(appCtx, models.PPMShipment{}, ppmShipment)
	if err != nil {
		return &models.PPMCloseout{}, err
	}
	if ppmShipment.FinalIncentive != nil {
		if *ppmShipment.HasReceivedAdvance && ppmShipment.AdvanceAmountReceived != nil {
			remainingIncentive = *ppmShipment.FinalIncentive - *ppmShipment.AdvanceAmountReceived
		} else {
			remainingIncentive = *ppmShipment.FinalIncentive
		}
	} else {
		remainingIncentive = unit.Cents(0)
	}

	// in cases where the PPM is a small package, the final incentive isn't able to be calculated until after TIO reviews/approves their expenses
	// because of this, we will update the final incentive here if the value is nil or different
	if ppmShipment.PPMType == models.PPMTypeSmallPackage &&
		ppmShipment.FinalIncentive != nil &&
		(previousFinalIncentive == nil || *previousFinalIncentive != *ppmShipment.FinalIncentive) {
		verrs, err := appCtx.DB().ValidateAndUpdate(ppmShipment)
		if verrs.HasAny() {
			return nil, apperror.NewInvalidInputError(ppmShipment.ID, err, verrs, "unable to validate PPMShipment")
		} else if err != nil {
			return nil, apperror.NewQueryError("PPMShipment", err, "unable to update PPMShipment final incentive")
		}
	}

	proGearCustomerMax := unit.Pound(2000)
	proGearSpouseMax := unit.Pound(500)
	var fullAllowableWeight unit.Pound

	if ppmShipment.AllowableWeight != nil {
		fullAllowableWeight = *ppmShipment.AllowableWeight
	}

	fullWeightGCCShipment := ppmShipment

	// Set pro gear weights for the GCC calculation to the max allowed before calculating GCC price
	fullWeightGCCShipment.ProGearWeight = &proGearCustomerMax
	fullWeightGCCShipment.SpouseProGearWeight = &proGearSpouseMax
	gcc, _ := p.calculateGCC(appCtx, *fullWeightGCCShipment, fullAllowableWeight)

	serviceItems, err := p.getServiceItemPrices(appCtx, *ppmShipment)
	if err != nil {
		return nil, err
	}
	if serviceItems.storageReimbursementCosts != nil {
		gcc = gcc.AddCents(*serviceItems.storageReimbursementCosts)
	}

	if ppmShipment.GCCMultiplier != nil {
		ppmCloseoutObj.GCCMultiplier = &ppmShipment.GCCMultiplier.Multiplier
	} else {
		ppmCloseoutObj.GCCMultiplier = models.Float64Pointer(1.00)
	}

	ppmCloseoutObj.ID = &ppmShipmentID
	ppmCloseoutObj.PlannedMoveDate = &ppmShipment.ExpectedDepartureDate
	ppmCloseoutObj.ActualMoveDate = ppmShipment.ActualMoveDate
	ppmCloseoutObj.Miles = (*int)(ppmShipment.Shipment.Distance)
	ppmCloseoutObj.EstimatedWeight = ppmShipment.EstimatedWeight
	ppmCloseoutObj.ActualWeight = &actualWeight
	ppmCloseoutObj.ProGearWeightCustomer = &proGearWeightCustomer
	ppmCloseoutObj.ProGearWeightSpouse = &proGearWeightSpouse
	ppmCloseoutObj.GrossIncentive = ppmShipment.FinalIncentive
	ppmCloseoutObj.GCC = &gcc
	ppmCloseoutObj.AOA = ppmShipment.AdvanceAmountReceived
	ppmCloseoutObj.RemainingIncentive = &remainingIncentive
	ppmCloseoutObj.HaulPrice = serviceItems.haulPrice
	ppmCloseoutObj.HaulFSC = serviceItems.haulFSC
	ppmCloseoutObj.HaulType = &serviceItems.haulType
	ppmCloseoutObj.DOP = serviceItems.dop
	ppmCloseoutObj.DDP = serviceItems.ddp
	ppmCloseoutObj.PackPrice = serviceItems.packPrice
	ppmCloseoutObj.UnpackPrice = serviceItems.unpackPrice
	ppmCloseoutObj.IntlLinehaulPrice = serviceItems.intlLinehaulPrice
	ppmCloseoutObj.IntlUnpackPrice = serviceItems.intlUnpackPrice
	ppmCloseoutObj.IntlPackPrice = serviceItems.intlPackPrice
	ppmCloseoutObj.SITReimbursement = serviceItems.storageReimbursementCosts

	return &ppmCloseoutObj, nil
}

/*
* returns calculated gcc
 */
func (p *ppmCloseoutFetcher) calculateGCC(appCtx appcontext.AppContext, ppmShipment models.PPMShipment, fullEntitlementWeight unit.Pound) (unit.Cents, error) {
	var gcc unit.Cents
	var fullEntitlementPPM models.PPMShipment
	err := copier.CopyWithOption(&fullEntitlementPPM, ppmShipment, copier.Option{IgnoreEmpty: false, DeepCopy: true})
	if err != nil {
		return unit.Cents(0), err
	}
	fullEntitlementPPM.SITEstimatedWeight = &fullEntitlementWeight

	// If SITExpected is set to true but the required fields (SITEstimatedStart, SITEstimatedEnd, SITEstimatedCost) are not set (bug/design issue with GUI workflow),
	// then set SITExpected to false, or else the estimator will return an error.
	if *ppmShipment.SITExpected && (ppmShipment.SITEstimatedEntryDate == nil || ppmShipment.SITEstimatedDepartureDate == nil ||
		ppmShipment.SITEstimatedCost == nil || ppmShipment.SITEstimatedWeight == nil) {
		newFalse := false
		ppmShipment.SITExpected = &newFalse
		fullEntitlementPPM.SITExpected = &newFalse
	}

	// Create a single weight ticket with the max weight, and use that to price the GCC
	// GCC is priced as if all was moved in one lot and must be to/from the authorized ZIPs/addresses
	var weightTicket models.WeightTicket
	if (ppmShipment.WeightTickets != nil) && len(ppmShipment.WeightTickets) > 0 {
		weightTicket = ppmShipment.WeightTickets[0]
	} else {
		weightTicket = models.WeightTicket{}
	}
	weightTicket.AdjustedNetWeight = &fullEntitlementWeight
	fullEntitlementPPM.WeightTickets = models.WeightTickets{weightTicket}

	finalIncentive, err := p.estimator.FinalIncentiveWithDefaultChecks(appCtx, ppmShipment, &fullEntitlementPPM)
	if err != nil {
		return gcc, err
	}
	if finalIncentive != nil {
		gcc = gcc.AddCents(*finalIncentive)
	}
	return gcc, err
}

/*
* returns
* customer pro gear weight, spouse pro gear weight
 */
func (p *ppmCloseoutFetcher) GetProGearWeights(ppmShipment models.PPMShipment) (unit.Pound, unit.Pound) {
	var totalWeightCustomer unit.Pound
	var totalWeightSpouse unit.Pound
	if len(ppmShipment.ProgearWeightTickets) >= 1 {
		for _, weightTicket := range ppmShipment.ProgearWeightTickets {
			if weightTicket.Status != nil && *weightTicket.BelongsToSelf && weightTicket.Weight != nil && *weightTicket.Status != models.PPMDocumentStatusRejected {
				totalWeightCustomer += *weightTicket.Weight
			} else if !*weightTicket.BelongsToSelf {
				totalWeightSpouse += *weightTicket.Weight
			}
		}
	}
	return totalWeightCustomer, totalWeightSpouse
}

func (p *ppmCloseoutFetcher) GetPPMShipment(appCtx appcontext.AppContext, ppmShipmentID uuid.UUID) (*models.PPMShipment, error) {
	var ppmShipment models.PPMShipment
	err := appCtx.DB().Scope(utilities.ExcludeDeletedScope()).
		EagerPreload(
			"ID",
			"Shipment",
			"ExpectedDepartureDate",
			"ActualMoveDate",
			"EstimatedWeight",
			"WeightTickets",
			"MovingExpenses",
			"ProgearWeightTickets",
			"FinalIncentive",
			"AdvanceAmountReceived",
			"Shipment.Distance",
			"PickupAddress",
			"DestinationAddress",
			"GCCMultiplier",
		).
		Find(&ppmShipment, ppmShipmentID)

	if err != nil {
		switch err {
		case sql.ErrNoRows:
			return nil, apperror.NewNotFoundError(ppmShipmentID, "unable to find PPMShipment")
		default:
			return nil, apperror.NewQueryError("PPMShipment", err, "while looking for PPMShipment")
		}
	}

	// the following checks are needed since we can't use "ExcludeDeletedScope()" in the big query above
	// this is because not all of the tables being queried have "deleted_at" columns and this returns an error
	if ppmShipment.WeightTickets != nil {
		var filteredWeightTickets []models.WeightTicket
		// We do not need to consider deleted weight tickets or uploads within them
		for _, wt := range ppmShipment.WeightTickets {
			if wt.DeletedAt == nil {
				wt.EmptyDocument.UserUploads = wt.EmptyDocument.UserUploads.FilterDeleted()
				wt.FullDocument.UserUploads = wt.FullDocument.UserUploads.FilterDeleted()
				wt.ProofOfTrailerOwnershipDocument.UserUploads = wt.ProofOfTrailerOwnershipDocument.UserUploads.FilterDeleted()
				filteredWeightTickets = append(filteredWeightTickets, wt)
			}
		}
		ppmShipment.WeightTickets = filteredWeightTickets
	}
	// We do not need to consider deleted moving expenses
	if len(ppmShipment.MovingExpenses) > 0 {
		ppmShipment.MovingExpenses = ppmShipment.MovingExpenses.FilterDeleted()
	}
	// We do not need to consider deleted progear weight tickets
	if len(ppmShipment.ProgearWeightTickets) > 0 {
		ppmShipment.ProgearWeightTickets = ppmShipment.ProgearWeightTickets.FilterDeleted()
	}

	var weightTicket models.WeightTicket

	if len(ppmShipment.WeightTickets) >= 1 {
		weightTicket = ppmShipment.WeightTickets[0]
	}

	// Check if PPM shipment is in "NEEDS_CLOSEOUT" or "CLOSEOUT_COMPLETE" status or if weight ticket was reviewed already, if not, it's not ready for closeout
	if weightTicket.Status == nil && ppmShipment.Status != models.PPMShipmentStatusNeedsCloseout && ppmShipment.Status != models.PPMShipmentStatusCloseoutComplete {
		return nil, apperror.NewPPMNotReadyForCloseoutError(ppmShipmentID, "PPM is not ready for closeout - must be in NEEDS_CLOSEOUT or CLOSEOUT_COMPLETE status")
	}

	return &ppmShipment, err
}

func (p *ppmCloseoutFetcher) GetActualWeight(ppmShipment *models.PPMShipment) unit.Pound {
	var totalWeight unit.Pound
	// small package PPMs do not have weight tickets so we will add up moving expenses
	if ppmShipment.PPMType == models.PPMTypeSmallPackage {
		if len(ppmShipment.MovingExpenses) >= 1 {
			for _, movingExpense := range ppmShipment.MovingExpenses {
				if movingExpense.WeightShipped != nil && *movingExpense.Status != models.PPMDocumentStatusRejected {
					totalWeight += *movingExpense.WeightShipped
				}
			}
			return totalWeight
		} else {
			return unit.Pound(0)
		}
	}

	if len(ppmShipment.WeightTickets) >= 1 {
		for _, weightTicket := range ppmShipment.WeightTickets {
			if weightTicket.FullWeight != nil && weightTicket.EmptyWeight != nil && (weightTicket.Status == nil || *weightTicket.Status != models.PPMDocumentStatusRejected) {
				totalWeight += *weightTicket.FullWeight - *weightTicket.EmptyWeight
			}
		}
	} else {
		return unit.Pound(0)
	}
	return totalWeight
}

func (p *ppmCloseoutFetcher) GetExpenseStoragePrice(appCtx appcontext.AppContext, ppmShipmentID uuid.UUID) (unit.Cents, error) {
	var expenseItems []models.MovingExpense
	var storageExpensePrice unit.Cents
	err := appCtx.DB().Where("ppm_shipment_id = ?", ppmShipmentID).All(&expenseItems)
	if err != nil {
		return unit.Cents(0), err
	}

	for _, movingExpense := range expenseItems {
		if movingExpense.MovingExpenseType != nil && movingExpense.Status != nil && *movingExpense.MovingExpenseType == models.MovingExpenseReceiptTypeStorage && *movingExpense.Status == models.PPMDocumentStatusApproved {
			storageExpensePrice += *movingExpense.Amount
		}
	}
	return storageExpensePrice, err
}

func paramsForServiceCode(code models.ReServiceCode, serviceParams models.ServiceParams) models.ServiceParams {
	var serviceItemParams models.ServiceParams
	for _, serviceParam := range serviceParams {
		if serviceParam.Service.Code == code {
			serviceItemParams = append(serviceItemParams, serviceParam)
		}
	}
	return serviceItemParams
}

func (p *ppmCloseoutFetcher) getServiceItemPrices(appCtx appcontext.AppContext, ppmShipment models.PPMShipment) (serviceItemPrices, error) {
	// Get all DLH, FSC, DOP, DDP, DPK, and DUPK service items for the shipment
	var serviceItemsToPrice []models.MTOServiceItem
	var returnPriceObj serviceItemPrices
	logger := appCtx.Logger()

	isInternationalShipment := ppmShipment.Shipment.MarketCode == models.MarketCodeInternational
	serviceItemsToPrice = ppmshipment.BaseServiceItems(ppmShipment)
	gccMultiplier := ppmShipment.GCCMultiplier

	if ppmShipment.PickupAddress == nil || ppmShipment.DestinationAddress == nil {
		return serviceItemPrices{}, apperror.NewBadDataError("Cannot have a nil address")
	}

	actualPickupPostal := ppmShipment.PickupAddress.PostalCode
	actualDestPostal := ppmShipment.DestinationAddress.PostalCode
	// Change DLH to DSH if move within same Zip3 (only for domestic shipments - intl uses ISLH)
	if !isInternationalShipment && actualPickupPostal[0:3] == actualDestPostal[0:3] {
		serviceItemsToPrice[0] = models.MTOServiceItem{ReService: models.ReService{Code: models.ReServiceCodeDSH}, MTOShipmentID: &ppmShipment.ShipmentID}
	}
	contractDate := ppmShipment.ExpectedDepartureDate
	contract, err := serviceparamvaluelookups.FetchContract(appCtx, contractDate)
	if err != nil {
		return serviceItemPrices{}, err
	}

	paramsForServiceItems, paramErr := p.paymentRequestHelper.FetchServiceParamsForServiceItems(appCtx, serviceItemsToPrice)
	if paramErr != nil {
		return serviceItemPrices{}, paramErr
	}

	var totalPrice, packPrice, unpackPrice, destinationPrice, originPrice, haulPrice, haulFSC, intlPackPrice, intlUnpackPrice, intlLinehaulPrice unit.Cents
	var ppmToMtoShipment models.MTOShipment

	var blankPPM models.PPMShipment
	// adding all the weight tickets together to get the total weight of the moved PPM
	// or if PPM-SPR - total the moving expenses
	_, totalWeight := ppmshipment.SumWeights(blankPPM, ppmShipment)

	if ppmShipment.AllowableWeight != nil && *ppmShipment.AllowableWeight < totalWeight {
		totalWeight = *ppmShipment.AllowableWeight
	}

	if totalWeight > 0 {
		// Reassign ppm shipment fields to their expected location on the mto shipment for dates, addresses, weights ...
		ppmToMtoShipment = ppmshipment.MapPPMShipmentFinalFields(ppmShipment, totalWeight)
	} else {
		// Reassign ppm shipment fields to their expected location on the mto shipment for dates, addresses, weights ...
		ppmToMtoShipment, err = ppmshipment.MapPPMShipmentEstimatedFields(appCtx, ppmShipment)
		if err != nil {
			logger.Error("unable to map PPM estimated fields", zap.Error(err))
			return serviceItemPrices{}, err
		}
	}

	sitCosts, err := p.GetExpenseStoragePrice(appCtx, ppmShipment.ID)
	if err != nil {
		logger.Error("Error calculating SIT Reimbursement Costs", zap.Error(err))
		return serviceItemPrices{}, err
	}

	// combo of domestic & int'l service items
	validCodes := map[models.ReServiceCode]string{
		models.ReServiceCodeDPK:   "DPK",
		models.ReServiceCodeDUPK:  "DUPK",
		models.ReServiceCodeDOP:   "DOP",
		models.ReServiceCodeDDP:   "DDP",
		models.ReServiceCodeDSH:   "DSH",
		models.ReServiceCodeDLH:   "DLH",
		models.ReServiceCodeFSC:   "FSC",
		models.ReServiceCodeISLH:  "ISLH",
		models.ReServiceCodeIHPK:  "IHPK",
		models.ReServiceCodeIHUPK: "IHUPK",
	}

	// If service item is of a type we need for a specific calculation, get its price
	for _, serviceItem := range serviceItemsToPrice {
		_, isValidCode := validCodes[serviceItem.ReService.Code]
		if !isValidCode {
			continue
		} // Next iteration of loop if we don't need this service type

		pricer, err := ghcrateengine.PricerForServiceItem(serviceItem.ReService.Code)
		if err != nil {
			logger.Error("unable to find pricer for service item", zap.Error(err))
			return serviceItemPrices{}, err
		}

		// For the non-accessorial service items there isn't any initialization that is going to change between lookups
		// for the same param. However, this is how the payment request does things and we'd want to know if it breaks
		// rather than optimizing I think.
		serviceItemLookups := serviceparamvaluelookups.InitializeLookups(appCtx, ppmToMtoShipment, serviceItem)

		// This is the struct that gets passed to every param lookup() method that was initialized above
		keyData := serviceparamvaluelookups.NewServiceItemParamKeyData(p.planner, serviceItemLookups, serviceItem, ppmToMtoShipment, contract.Code, contract.ID)

		// The distance value gets saved to the mto shipment model to reduce repeated api calls.
		var shipmentWithDistance models.MTOShipment
		err = appCtx.DB().Eager("PPMShipment").Find(&shipmentWithDistance, ppmShipment.Shipment.ID)
		if err != nil {
			logger.Error("could not find shipment in the database")
			return serviceItemPrices{}, err
		}
		serviceItem.MTOShipment = shipmentWithDistance
		// set this to avoid potential eTag errors because the MTOShipment.Distance field was likely updated
		ppmShipment.Shipment = shipmentWithDistance

		var paramValues models.PaymentServiceItemParams
		for _, param := range paramsForServiceCode(serviceItem.ReService.Code, paramsForServiceItems) {
			paramKey := param.ServiceItemParamKey
			// This is where the lookup() method of each service item param is actually evaluated
			paramValue, serviceParamErr := keyData.ServiceParamValue(appCtx, paramKey.Key)
			if serviceParamErr != nil {
				logger.Error("could not calculate param value lookup", zap.Error(serviceParamErr))
				return serviceItemPrices{}, serviceParamErr
			}

			// Gather all the param values for the service item to pass to the pricer's Price() method
			paymentServiceItemParam := models.PaymentServiceItemParam{
				// Some pricers like Fuel Surcharge try to requery the shipment through the service item, this is a
				// workaround to avoid a not found error because our PPM shipment has no service items saved in the db.
				// I think the FSC service item should really be relying on one of the zip distance params.
				PaymentServiceItem: models.PaymentServiceItem{
					MTOServiceItem: serviceItem,
				},
				ServiceItemParamKey: paramKey,
				Value:               paramValue,
			}
			paramValues = append(paramValues, paymentServiceItemParam)
		}

		if len(paramValues) == 0 {
			return serviceItemPrices{}, fmt.Errorf("no params were found for service item %s", serviceItem.ReService.Code)
		}

		// Middle var here can give you info on payment params like FSC multiplier, price rate/factor, etc. if needed.
		centsValue, _, err := pricer.PriceUsingParams(appCtx, paramValues)
		if err != nil {
			return serviceItemPrices{}, err
		}
		// apply multiplier if it's there
		if gccMultiplier != nil && gccMultiplier.Multiplier > 0 && centsValue > 0 {
			multiplier := gccMultiplier.Multiplier
			multipliedPrice := float64(centsValue) * multiplier
			centsValue = unit.Cents(int(multipliedPrice))
		}

		totalPrice = totalPrice.AddCents(centsValue)

		switch serviceItem.ReService.Code {
		case models.ReServiceCodeIHPK: // Int'l pack
			intlPackPrice += centsValue
		case models.ReServiceCodeIHUPK: // Int'l unpack
			intlUnpackPrice += centsValue
		case models.ReServiceCodeISLH: // Int'l shipping & linehaul
			intlLinehaulPrice += centsValue
		case models.ReServiceCodeDPK:
			packPrice += centsValue
		case models.ReServiceCodeDUPK:
			unpackPrice += centsValue
		case models.ReServiceCodeDOP:
			originPrice += centsValue
		case models.ReServiceCodeDDP:
			destinationPrice += centsValue
		case models.ReServiceCodeDSH, models.ReServiceCodeDLH:
			haulPrice += centsValue
			_, linehaulOk := pricer.(services.DomesticLinehaulPricer)
			if linehaulOk {
				returnPriceObj.haulType = models.HaulType(models.LINEHAUL)
			} else {
				_, shorthaulOk := pricer.(services.DomesticShorthaulPricer)
				if shorthaulOk {
					returnPriceObj.haulType = models.HaulType(models.SHORTHAUL)
				} else { // Fallback in case pricer comparison fails
					if ppmToMtoShipment.DestinationAddress.PostalCode[0:3] == ppmToMtoShipment.PickupAddress.PostalCode[0:3] {
						returnPriceObj.haulType = models.HaulType(models.SHORTHAUL)
					} else {
						returnPriceObj.haulType = models.HaulType(models.LINEHAUL)
					}
				}
			}
		case models.ReServiceCodeFSC:
			haulFSC += centsValue
		}
	}
	returnPriceObj.ddp = &destinationPrice
	returnPriceObj.dop = &originPrice
	returnPriceObj.packPrice = &packPrice
	returnPriceObj.unpackPrice = &unpackPrice
	returnPriceObj.storageReimbursementCosts = &sitCosts
	returnPriceObj.haulPrice = &haulPrice
	returnPriceObj.haulFSC = &haulFSC
	returnPriceObj.intlLinehaulPrice = &intlLinehaulPrice
	returnPriceObj.intlPackPrice = &intlPackPrice
	returnPriceObj.intlUnpackPrice = &intlUnpackPrice

	return returnPriceObj, nil
}
