#! /usr/bin/env bash

set -eux -o pipefail

# Setting REACT_APP_NODE_ENV to develompent enables the "Local Sign In" button
export REACT_APP_NODE_ENV=development

# Set the container default name
CONTAINER=mymove_milmove_1
CONTAINER_CYPRESS=cypress

# Set hostnames
MILMOVEHOST=milmovelocal
OFFICEHOST=officelocal
TSPHOST=tsplocal
ADMINHOST=adminlocal
ORDERSHOST=orderslocal

# Set Defaults
HTTP_PORT=4000
NETWORK="mymove_default" # Docker network

# When running locally enable TTY
DOCKER_RUN="docker run -t"
if [ -n "${CIRCLECI+x}" ]; then
  echo "RUNNING IN CIRCLECI"
  DOCKER_RUN="docker run"
fi

# Check that the docker process is running first
docker system info >> /dev/null

# Begin Setup
make e2e_clean

if [[ -n "${CIRCLECI+x}" ]]; then
  # CI/CD allows us to use pre-built images using the branch name

  # TODO: Consider using "--rmi all" when running locally
  docker-compose down || true

  # Docker Compose Setup
  aws ecr get-login --no-include-email --region us-west-2 --no-include-email | sh
  scripts/update-docker-compose
  docker-compose up --no-start

  # Can't mount folders in CircleCI so copy this data in
  # https://circleci.com/docs/2.0/building-docker-images/#mounting-folders
  echo "Copy in the local migration files"
  docker cp ./local_migrations mymove_milmove_migrate_1:/mymove/

  echo "Start everything up"
  docker-compose up -d --no-recreate

else
  # Locally development requires that we build the container

  # TODO: Consider using "--rmi all" when running locally
  docker-compose -f docker-compose.local.yml down || true

  # Build artifacts
  make client_build server_build_linux bin_linux/milmove

  echo "Start everything up"
  docker-compose -f docker-compose.local.yml up -d --build
fi

# Following the logs should block any more actions until migrations are completed and the container exits
echo "Follow the migration logs"
docker-compose logs -f milmove_migrate

# Need to wait not just for DB but also migrations to finish
while true; do
  MIGRATE_EXIT=$(docker ps --filter="name=mymove_milmove_migrate_1" --filter="status=exited" -q)
  if [[ -n "${MIGRATE_EXIT}" ]]; then
    break
  else
    echo "Waiting 5 seconds for migrations to complete"
    sleep 5
  fi
done

MIGRATE_EXIT_CODE=$(docker inspect --format='{{.State.ExitCode}}' mymove_milmove_migrate_1)
if [[ "${MIGRATE_EXIT_CODE}" != "0" ]]; then
  echo "Migration exited with exit code ${MIGRATE_EXIT_CODE}"
  exit 1
fi

# Build a small tools dockerfile
make bin_linux/generate-test-data
echo "Build tools docker container"
docker build -f Dockerfile.tools --tag tools:latest .
echo "Truncate the DB"
$DOCKER_RUN \
  --link="database" \
  --net "${NETWORK}" \
  --rm \
  --entrypoint psql \
  tools:latest \
  postgres://postgres:mysecretpassword@database:5432/dev_db?sslmode=disable -c 'TRUNCATE users CASCADE;'
echo "Generate Test Data"
$DOCKER_RUN \
  -t \
  -e DB_NAME=dev_db \
  -e DB_HOST=database \
  -e DB_PORT=5432 \
  -e DB_USER=postgres \
  -e DB_PASSWORD=mysecretpassword \
  --link="database" \
  --net "${NETWORK}" \
  --rm \
  --entrypoint generate-test-data \
  tools:latest \
  --named-scenario e2e_basic

# Grab the IP address of the running container
E2E_IP=$(docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' ${CONTAINER})

# Run the cypress tests
docker build -f Dockerfile.cypress --tag ${CONTAINER_CYPRESS}:latest .

# Confirm app container is still running before running tests
# See note above about what to do if you need to debug
DOCKER_PID=$(docker ps -qf name=${CONTAINER})
if [ -z "${DOCKER_PID}" ]; then
  echo
  echo "Docker container ${CONTAINER} exited unexpectedly. No tests will be run. "
  exit 1
fi

readonly spec="${SPEC:-cypress/integration/**/*}"
echo "Testing this SPEC: ${spec}"

$DOCKER_RUN \
  -e CYPRESS_baseUrl="http://${MILMOVEHOST}:${HTTP_PORT}" \
  --add-host "${MILMOVEHOST}:${E2E_IP}" \
  --add-host "${OFFICEHOST}:${E2E_IP}" \
  --add-host "${TSPHOST}:${E2E_IP}" \
  --add-host "${ADMINHOST}:${E2E_IP}" \
  --add-host "${ORDERSHOST}:${E2E_IP}" \
  --name="${CONTAINER_CYPRESS}" \
  --link="${CONTAINER}" \
  --net "${NETWORK}" \
  --ipc=host \
  --detach \
  ${CONTAINER_CYPRESS}:latest run --spec "${spec}"

# Tail the logs so users can follow along
docker logs -f ${CONTAINER_CYPRESS}

# Stop the app container to release the DB connection
docker stop ${CONTAINER}

# Copy out the results
docker cp ${CONTAINER_CYPRESS}:/cypress/results cypress/ 2>/dev/null || echo "No cypress results copied"
docker cp ${CONTAINER_CYPRESS}:/cypress/screenshots cypress/ 2>/dev/null || echo "No cypress screenshots copied"
docker cp ${CONTAINER_CYPRESS}:/cypress/videos cypress/ 2>/dev/null || echo "No cypress videos copied"

# Grab the exit code from the test container
EXIT_STATUS=$(docker inspect ${CONTAINER_CYPRESS} --format='{{.State.ExitCode}}')

# Exit with the status from tests
exit "${EXIT_STATUS}"
